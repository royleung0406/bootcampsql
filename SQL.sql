use sys;

CREATE DATABASE BOOTCAMP_2408;
use BOOTCAMP_2408;

-- Comments in SQL (double-dash)
-- Database -> tables
	-- One database may have many tables
    -- One table (similar to excel worksheet) may have rows
    -- One row contains one or more columns
    
-- Database: column defintions: VATCHAR(Similar to Java String), INT/ INTEGER(Java: int)
-- DECIMAL(13,2) 11 digits for integer, 2 digits for decimal places
-- boolean (true/ false): database normally we use VARCHAR(1) -> Y/N
CREATE TABLE STAFFS (
	ID INTEGER, -- 1,2,3,4 ...
    STAFF_NAME VARCHAR(20),
    GENDER VARCHAR(1),
    SALARY DECIMAL(11,2),
    STAFF_EMAIL VARCHAR(50),
    DEPT_CODE VARCHAR(2) -- IT, HR, MK ...
);

-- DROP TABLE STAFFS;

SELECT * FROM STAFFS;

-- INSERT DATA
-- SYNTAX: INSERT INTO "TABLE_NAME" VALUES ...
-- Column name sequence has to be same as the value sequence 
INSERT INTO STAFFS (ID, STAFF_NAME, GENDER, SALARY, STAFF_EMAIL, DEPT_CODE) 
	VALUES (1, 'JOHN WONG', 'M', 20000.5, 'johnwong@gmail.com', 'IT');

INSERT INTO STAFFS (ID, STAFF_NAME, GENDER, SALARY, STAFF_EMAIL, DEPT_CODE) 
	VALUES (2, 'PETER LAU', 'M', 31000.0, 'peterwong@hotmail.com', 'HR');

-- remove data
-- DELETE FROM STAFFS; -- REMOVE ALL DATA

-- table may contain null value
INSERT INTO STAFFS (ID, STAFF_NAME, GENDER, SALARY, DEPT_CODE) 
	VALUES (3, 'JENNY LAU', 'F', 25000.0, 'MK');
INSERT INTO STAFFS (ID, STAFF_NAME, GENDER, SALARY, DEPT_CODE, STAFF_EMAIL) 
	VALUES (2, 'PETER LAU', 'M', 31000.0, 'HR', NULL);
    
-- SELECT BY CONDITION (WHERE)
SELECT * FROM STAFFS WHERE GENDER = 'M';
-- WHERE DEPT_CODE = 'IT'
SELECT * FROM STAFFS WHERE DEPT_CODE = 'IT';
-- AND, OR
SELECT * FROM STAFFS WHERE DEPT_CODE = 'IT' OR DEPT_CODE = 'MK';
SELECT * FROM STAFFS WHERE DEPT_CODE IN ('IT', 'MK'); -- OR
SELECT * FROM STAFFS WHERE DEPT_CODE = 'IT' AND DEPT_CODE = 'MK'; -- NO RESULT
SELECT * FROM STAFFS WHERE DEPT_CODE = 'IT' AND GENDER = 'M';
-- SUPPORT BRACKETS
SELECT * FROM STAFFS WHERE DEPT_CODE = 'IT' OR DEPT_CODE = 'MK' AND GENDER = 'F'; -- AND GO FIRST, THEN OR
SELECT * FROM STAFFS WHERE DEPT_CODE = 'IT' AND (SALARY > 19000 OR GENDER = 'F'); -- OR GO FIRST, THEN AND
-- SELECT SPECIFIC COLUMNS
-- SYNTAX: select "column_name1", "column_name2" ... from "table_name"
-- SELECT (WHAT YOU WANT TO SEE IN THE RESULT SET) -> COLUMNS
-- WHERE (HOW TO RETRIEVE THE DATA) -> ROWS
SELECT STAFF_NAME, DEPT_CODE FROM STAFFS WHERE GENDER = 'M';

-- CHANGE COLUMN NAME IN RESULT SET (NOT THE PHYSICAL TABLE)
SELECT STAFF_NAME AS NAME, DEPT_CODE AS DEPARTMENT_CODE FROM STAFFS WHERE GENDER = 'M';

-- ADD COLUMN IN PHYSICAL TABLE
ALTER TABLE STAFFS ADD EMPLOYMENT_DATE DATE;

-- AFTER ADDING COLUMN, THE COLUMN VALUES BECOME NULL FOR ALL ROWS
SELECT * FROM STAFFS;

-- UPDATE FIELD VALUES
UPDATE STAFFS SET EMPLOYMENT_DATE = STR_TO_DATE('2014-08-01', '%Y-%m-%d') WHERE ID = 1;
UPDATE STAFFS SET EMPLOYMENT_DATE = STR_TO_DATE('2018-09-05', '%Y-%m-%d') WHERE ID = 2;
UPDATE STAFFS SET EMPLOYMENT_DATE = STR_TO_DATE('2019-03-31', '%Y-%m-%d') WHERE ID = 3;

-- CALCULATE PROBATION END DATE
-- DEFINE TABLE ALIAS
SELECT DATE_ADD(S.EMPLOYMENT_DATE, INTERVAL 3 MONTH) AS PROBATION_END_DATE
, S.STAFF_NAME
, S.ID
, S.EMPLOYMENT_DATE 
, S.EMPLOYMENT_DATE + 33 -- DATE -> INT + OPERATION (MYSQL NOT WORKING)
FROM STAFFS S;

-- MYSQL (NOT WORKING)
SELECT S.STAFF_NAME + '!!!!', CONCAT(S.STAFF_NAME, '!!!!')
FROM STAFFS S;

-- SELECT DETERMINE WHAT COLUMNS
SELECT S.STAFF_NAME + '!!!!'
, CONCAT(S.STAFF_NAME, '!!!!', '?????')
, CONCAT_WS(' ', S.STAFF_NAME, S.GENDER)
FROM STAFFS S
WHERE S.DEPT_CODE = 'IT'; -- DETERMINE THE NUMBER OF ROWS

-- MATH OPERATIONS (+, -, *, /, %)
-- 15 FIELDS (3 ROWS x 5 COLUMNS)
SELECT SALARY + 10000, SALARY, 12000 - 200 * 1.1, 1, 'HELLO'
FROM STAFFS;

SELECT 10 % 3, 'HELLO' FROM STAFFS WHERE DEPT_CODE IN ('MK', 'HR');

-- BETWEEN AND
SELECT *
FROM STAFFS
WHERE EMPLOYMENT_DATE BETWEEN STR_TO_DATE('2014-01-01', '%Y-%m-%d') AND STR_TO_DATE('2014-12-31', '%Y-%m-%d');

-- MODIFY PHYSICAL COLUMN DEFINTION
-- FROM VARCHAR(20) TO VARCHAR(30) -> EXTEND COLUMN LENGTH
ALTER TABLE STAFFS MODIFY STAFF_NAME VARCHAR(30);

INSERT INTO STAFFS (ID, STAFF_NAME, GENDER, SALARY, DEPT_CODE) 
	VALUES (4, 'VINCENT ABCDEFGHIJK ABCDEF', 'M', 15000.0, 'IT');
    
-- FROM VARCHAR(30) TO VARCHAR(20) -- NARROWING (DATA CHECKING)
-- IF EXISTING DATA LENGTH > NEW COLUMN LENGTH, DBMS WILL REJECT
ALTER TABLE STAFFS MODIFY STAFF_NAME VARCHAR(20);

UPDATE STAFFS SET STAFF_EMAIL = 'vincentlau@hotmail.com' WHERE ID = 4;

-- LIKE
-- "%" MEANS ANY CHARACTERS
SELECT *
FROM STAFFS
WHERE DEPT_CODE = 'IT'
AND STAFF_EMAIL LIKE '%@gmail.com';


INSERT INTO STAFFS (ID, STAFF_NAME, GENDER, SALARY, DEPT_CODE) 
	VALUES (5, 'JOHN LAU', 'M', 20500.0, 'MK');

SELECT *
FROM STAFFS
WHERE STAFF_NAME LIKE 'JOHN%';

SELECT *
FROM STAFFS
WHERE STAFF_EMAIL LIKE '%@%' OR STAFF_EMAIL IS NULL;

-- AGGREGATION FUNCTIONS + WHERE
SELECT SUM(SALARY)
FROM STAFFS;

SELECT SUM(SALARY)
FROM STAFFS
WHERE DEPT_CODE = 'IT';

-- SUM() -> SUM UP ALL THE VALUE OF A COLUMN
-- COUNT() -> COUNT THE NUMBER OF ROWS
-- YOU CANNOT PUT STAFF_NAME HERE, YOU SHOULD KNOW THE REASON
-- AS LONG AS YOU HAVE ONE AGGREGATION FUNCTION, THE RESULT MUST BE SINGLE ROW
SELECT SUM(SALARY), COUNT(1), COUNT(*), COUNT(ID), MIN(SALARY), MAX(SALARY), MAX(ID), AVG(SALARY) -- , STAFF_NAME 
FROM STAFFS
WHERE DEPT_CODE = 'IT';

SELECT 1 AS ONE FROM STAFFS WHERE DEPT_CODE = 'IT';

-- AGGREGATION FUNCTIONS + GROUP BY
-- 1. EXCLUDE THE EMPLOYEE IN MARKETING (WHERE IS THE ACTION BEFORE GROUP BY)
-- 2. GROUP BY
-- 3. SELECT AGG FUNCTIONS
SELECT DEPT_CODE, AVG(SALARY) AS DEPT_AVERAGE_SALARY, COUNT(1) AS NUMBER_OF_DEPT_EMPLOYEES
, MAX(SALARY) DEPT_MAX_SALARY
FROM STAFFS
WHERE DEPT_CODE <> 'MK' -- EXCLUDE MARKETING
GROUP BY DEPT_CODE;

-- Day 2


-- ORDER BY (BY DEFAULT ASC)
SELECT * FROM STAFFS 
ORDER BY STAFF_NAME ASC;

-- NULL VALUES COME FIRST
SELECT * FROM STAFFS 
ORDER BY STAFF_EMAIL;

-- ORDER BY MULTIPLE COLUMNS
SELECT * FROM STAFFS
ORDER BY GENDER DESC, STAFF_NAME DESC;

SELECT * FROM STAFFS
ORDER BY EMPLOYMENT_DATE DESC;

-- EXAMPLE 1: GROUP BY + HAVING (AGG FUNCTIONS)
SELECT GENDER, SUM(SALARY) AS SUM_OF_SALARY
FROM STAFFS
WHERE STAFF_NAME LIKE '%LAU' -- FILTER DATA (BEFORE GROUP BY)
GROUP BY GENDER
HAVING COUNT(1) > 1; -- FILTER GROUP

-- RESULT
-- M 51500.00

-- EXPLAINATION OF THE ABOVE:
-- STEP 1: FILTER DATA (BEFORE GROUP)
SELECT 'HELLO', S.*
FROM STAFFS S
WHERE S.STAFF_NAME LIKE '%LAU';

-- STEP 2: 
SELECT GENDER, SUM(SALARY) AS SUM_OF_SALARY
FROM STAFFS
WHERE STAFF_NAME LIKE '%LAU'
GROUP BY GENDER;

-- STEP 3: YOU CAN USE HAVING TO DETERMINE WHICH GROUP SHOULD EXIST
SELECT GENDER, SUM(SALARY) AS SUM_OF_SALARY
FROM STAFFS
WHERE STAFF_NAME LIKE '%LAU'
GROUP BY GENDER
HAVING COUNT('HELLO') > 1;

-- EXAMPLE 2: GROUP BY + HAVING
SELECT DEPT_CODE, SUM(SALARY) AS SUM_OF_SALARY, MIN(SALARY), AVG(SALARY) -- STAFF_NAME
FROM STAFFS
GROUP BY DEPT_CODE
HAVING MIN(SALARY) < 21000; -- FILTER OUT DEPT_CODE 'HR', BECAUSE MIN SALARY OF HR DEPARTMENT >= 21000

-- CASE WHEN THEN ELSE (JAVA: IF ELSE IF)
SELECT CASE
		WHEN DEPT_CODE = 'IT' THEN 'INFORMATION TECHNOLOGY'
        WHEN DEPT_CODE = 'HR' THEN 'HUMAN RESOURCE'
		WHEN DEPT_CODE = 'MK' THEN 'MARKETING'
        ELSE 'N/A'
	   END AS 'DEPT_DESCRIPTION'
,      CASE
		 WHEN SALARY > 30000 THEN 'H'
         WHEN SALARY > 20000 THEN 'M'
         ELSE 'S'
	   END AS 'SALARY_GROUP'
, STAFF_NAME, SALARY
FROM STAFFS;

-- DISTINCT (SHOW ALL POSSIBLE VALUES)
-- "DISTINCT GENDER, DEPT_CODE" -> DISTINCT 2 COLUMNS
-- YOU SHOULD NOT USE AGG FUNCTION WITH DISTINCT 
SELECT DISTINCT GENDER, DEPT_CODE
FROM STAFFS;

-- GROUP BY 2 COLUMNS
SELECT GENDER, DEPT_CODE, SUM(SALARY), MAX(SALARY)
FROM STAFFS
GROUP BY GENDER, DEPT_CODE; -- ONE GROUP DEFINTION

-- DROP TABLE ORDERS;
-- create table ORDERS with datetime
CREATE TABLE ORDERS (
	ID INTEGER,
    ORDER_DATETIME DATETIME,
    COUPON_CODE VARCHAR(10),
    ORDER_STATUS VARCHAR(1)
);

INSERT INTO ORDERS VALUES (1, STR_TO_DATE('2023-01-01 00:00:00', '%Y-%m-%d %T'), NULL, 'P');
INSERT INTO ORDERS VALUES (2, '2024-12-31 18:05:23', NULL, 'P');

-- LIMIT + ORDER BY
SELECT *
FROM STAFFS 
ORDER BY SALARY DESC
LIMIT 2; -- FIRST 2 ROWS OF THE RESULT SET AFTER ORDER BY

-- JOIN
CREATE TABLE NUMBERS (
	NUMBER1 INTEGER,
    NUMBER2 INTEGER
);
-- 3 x 2
INSERT INTO NUMBERS VALUES (1, 10);
INSERT INTO NUMBERS VALUES (2, 105);
INSERT INTO NUMBERS VALUES (3, 299);

CREATE TABLE NAMES(
	NAME1 VARCHAR(10),
    NAME2 VARCHAR(10),
	NUM INTEGER
);
-- 3 x 3
INSERT INTO NAMES VALUES ('JOHN', 'PETER', 2);
INSERT INTO NAMES VALUES ('JENNY', 'SALLY', 1);
INSERT INTO NAMES VALUES ('STEVEN', 'OSCAR', 4);

-- INNER JOIN (WITHOUT CONDITION)
-- Usage: Find out all combinations
-- 9 x 5 (9 = 3 x 3, 5 columns)
SELECT R.*, N.*
FROM NUMBERS R INNER JOIN NAMES N;

-- SELF INNER JOIN
SELECT R.*, N.*
FROM NUMBERS R INNER JOIN NAMES N ON R.NUMBER1 = N.NUM;

-- INNER JOIN: DEPARTMENTS + STAFFS 
-- ONE TO MANY: ONE STAFF BELONGS TO ONE DEPT, BUT ONE DEPT MAY HAVE MORE THAN ONE STAFF
CREATE TABLE DEPARTMENTS (
	ID INTEGER,
    DEPT_CODE VARCHAR(2),
    DEPT_DESC VARCHAR(100)
);
INSERT INTO DEPARTMENTS VALUES (1, 'IT', 'INFORMATION TECHNOLOGY');
INSERT INTO DEPARTMENTS VALUES (2, 'HR', 'HUMAN RESOURCES');
INSERT INTO DEPARTMENTS VALUES (3, 'MK', 'MARKETING');

-- INNER JOIN + ORDER BY
SELECT D.DEPT_DESC, S.STAFF_NAME, S.SALARY
FROM DEPARTMENTS D INNER JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
ORDER BY S.DEPT_CODE, S.SALARY DESC;

-- INNER JOIN + GROUP BY
SELECT D.DEPT_CODE, SUM(S.SALARY) AS DEPT_TOTAL_SALARY
FROM DEPARTMENTS D INNER JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
GROUP BY D.DEPT_CODE
ORDER BY DEPT_TOTAL_SALARY DESC; -- last step of SQL

-- LEFT JOIN (WITHOUT GROUP)
SELECT D.*, S.*
FROM DEPARTMENTS D LEFT JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE;


-- LEFT JOIN
INSERT INTO DEPARTMENTS VALUES (4, 'CS', 'CUSTOMER SERVICE');
-- CS DEPARTMENT HAS NO STAFF
SELECT D.DEPT_CODE, COUNT(S.ID) DEPT_STAFF_NUMBER
FROM DEPARTMENTS D LEFT JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
GROUP BY D.DEPT_CODE;

-- RIGHT JOIN (same result as the above)
SELECT D.DEPT_CODE, COUNT(S.ID) DEPT_STAFF_NUMBER
FROM STAFFS S RIGHT JOIN DEPARTMENTS D ON D.DEPT_CODE = S.DEPT_CODE
GROUP BY D.DEPT_CODE;

-- LEFT JOIN (WITHOUT INTERSECT)
SELECT D.DEPT_CODE, COUNT(S.ID) DEPT_STAFF_NUMBER
FROM DEPARTMENTS D LEFT JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
WHERE S.ID IS NULL
GROUP BY D.DEPT_CODE;

-- EXISTS/ NOT EXISTS (YOU HAVE TO USE A KEY TO MAP)
-- FIND THE DEPARTMENT WHICH HAS NO STAFF
-- DISADVANTAGE: YOU CANNOT SELECT COLUMN IN TABLE STAFF
SELECT D.*
FROM DEPARTMENTS D
WHERE NOT EXISTS (SELECT 1 FROM STAFFS S WHERE D.DEPT_CODE = S.DEPT_CODE);

SELECT D.*
FROM DEPARTMENTS D
WHERE EXISTS (SELECT 1 FROM STAFFS S WHERE D.DEPT_CODE = S.DEPT_CODE);

-- Day 3

-- Day3
USE BOOTCAMP_2408;

CREATE TABLE CUSTOMERS (
	ID INTEGER PRIMARY KEY, -- UNQIUE, NOT NULL
	CUSTOMER_NAME VARCHAR(50),
    VIP VARCHAR(1)
);

CREATE TABLE ORDERS (
	ID INTEGER PRIMARY KEY, -- UNQIUE, NOT NULL
	TOTAL_AMOUNT DECIMAL(11,2),
    CUSTOMER_ID INTEGER,
    -- CUSTOMER_ID -> ORDERS.CUSTOMER_ID (CURRENT TABLE COLUMN)
    -- ID -> CUSTOMERS.ID (ANOTHER TABLE PK)
    FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(ID)
);

INSERT INTO CUSTOMERS VALUES (1, 'JOHN LAU', 'Y');
-- INSERT INTO CUSTOMERS VALUES (1, 'PETER WONG', 'N'); -- PK EXISTS
INSERT INTO CUSTOMERS VALUES (2, 'PETER WONG', 'N');

INSERT INTO ORDERS VALUES (1, 100.9, 2); -- OK, CUSTOMER_ID 2 EXISTS
-- INSERT INTO ORDERS VALUES (2, 999.99, 3); -- NOT OK, CUSTOMER_ID 3 NOT EXISTS IN CUSTOMERS
INSERT INTO ORDERS VALUES (2, 999.99, 1);

-- TYPES OF TABLE
-- 1. SETUP TABLE (ADMIN SYSTEM CONTROL)
-- 2. TRANSACTION TABLE (USER ACTION)
-- 3. CUSTOMER BASED TABLE (USER ACTION)

-- SETUP TABLE (ADMIN SYSTEM CONTROL)
CREATE TABLE SETUP_DELIVERY_FEE(
	ORDER_TYPE VARCHAR(1),
    EFF_DATE DATE,
	TRAN_DATE DATE,
    AMOUNT DECIMAL(6,2),
    STATUS VARCHAR(1), -- 'A', 'I'
    PRIMARY KEY (ORDER_TYPE, EFF_DATE)
);

-- JAVA
-- CTE: SUB-QUERY
WITH MAX_EFF_DATE AS (
	SELECT MAX(EFF_DATE) AS MAX_DATE -- RESULT -> ONE ROW
	FROM SETUP_DELIVERY_FEE SDF
	WHERE SDF.ORDER_TYPE = 'C'
    AND SDF.EFF_DATE <= CURDATE() -- TODAY
    AND S.STATUS = 'A'
)
SELECT S.AMOUNT AS DELIVERY_FEE
FROM SETUP_DELIVERY_FEE S, MAX_EFF_DATE MED -- N X 1
WHERE S.ORDER_TYPE = 'C'
AND S.STATUS = 'A'
AND S.EFF_DATE = MED.MAX_DATE;

-- ALTERNATIVE: SUB-QUERY
-- THE EFFECTIVE DATE MAY COMPARE WITH SYSTEM DATE
SELECT S.AMOUNT AS DELIVERY_FEE
FROM SETUP_DELIVERY_FEE S
WHERE S.ORDER_TYPE = 'C'
AND S.STATUS = 'A'
AND S.EFF_DATE = (SELECT MAX(EFF_DATE) AS MAX_DATE -- RESULT -> ONE ROW
					FROM SETUP_DELIVERY_FEE SDF
					WHERE SDF.ORDER_TYPE = S.ORDER_TYPE
                    AND SDF.EFF_DATE <= CURDATE() -- TODAY
                    AND S.STATUS = 'A');

--
UPDATE SETUP_DELIVERY_FEE
SET STATUS = 'I'
WHERE ORDER_TYPE = 'C'
AND EFF_DATE = '2024-09-03';

-- AUTO_INCREMENT
CREATE TABLE FACULTY (
    ID INTEGER PRIMARY KEY AUTO_INCREMENT, -- DB auto find the max(id) and then + 1
    FACULTY_NAME VARCHAR(100) NOT NULL,
    FACULTY_HIRE_DATE DATE NOT NULL
);

-- MarkSix


-- Mark Six Example
CREATE TABLE MARKSIX (
	NUM INTEGER
);
INSERT INTO MARKSIX VALUES (1);
INSERT INTO MARKSIX VALUES (2);
INSERT INTO MARKSIX VALUES (3);
INSERT INTO MARKSIX VALUES (4);
INSERT INTO MARKSIX VALUES (5);
INSERT INTO MARKSIX VALUES (6);
INSERT INTO MARKSIX VALUES (7);
INSERT INTO MARKSIX VALUES (8);
INSERT INTO MARKSIX VALUES (9);
INSERT INTO MARKSIX VALUES (10);
INSERT INTO MARKSIX VALUES (11);
INSERT INTO MARKSIX VALUES (12);
INSERT INTO MARKSIX VALUES (13);
INSERT INTO MARKSIX VALUES (14);
INSERT INTO MARKSIX VALUES (15);
INSERT INTO MARKSIX VALUES (16);
INSERT INTO MARKSIX VALUES (17);
INSERT INTO MARKSIX VALUES (18);
INSERT INTO MARKSIX VALUES (19);
INSERT INTO MARKSIX VALUES (20);
INSERT INTO MARKSIX VALUES (21);
INSERT INTO MARKSIX VALUES (22);
INSERT INTO MARKSIX VALUES (23);
INSERT INTO MARKSIX VALUES (24);
INSERT INTO MARKSIX VALUES (25);
INSERT INTO MARKSIX VALUES (26);
INSERT INTO MARKSIX VALUES (27);
INSERT INTO MARKSIX VALUES (28);
INSERT INTO MARKSIX VALUES (29);
INSERT INTO MARKSIX VALUES (30);
INSERT INTO MARKSIX VALUES (31);
INSERT INTO MARKSIX VALUES (32);
INSERT INTO MARKSIX VALUES (33);
INSERT INTO MARKSIX VALUES (34);
INSERT INTO MARKSIX VALUES (35);
INSERT INTO MARKSIX VALUES (36);
INSERT INTO MARKSIX VALUES (37);
INSERT INTO MARKSIX VALUES (38);
INSERT INTO MARKSIX VALUES (39);
INSERT INTO MARKSIX VALUES (40);
INSERT INTO MARKSIX VALUES (41);
INSERT INTO MARKSIX VALUES (42);
INSERT INTO MARKSIX VALUES (43);
INSERT INTO MARKSIX VALUES (44);
INSERT INTO MARKSIX VALUES (45);
INSERT INTO MARKSIX VALUES (46);
INSERT INTO MARKSIX VALUES (47);
INSERT INTO MARKSIX VALUES (48);
INSERT INTO MARKSIX VALUES (49);

SELECT *
FROM MARKSIX NUM1 INNER JOIN MARKSIX NUM2 ON NUM1.NUM <> NUM2.NUM -- 49 X 49
INNER JOIN MARKSIX NUM3 ON NUM1.NUM <> NUM3.NUM
INNER JOIN MARKSIX NUM4 ON NUM1.NUM <> NUM4.NUM;

-- ALTERNATIVE FOR INNER JOIN
-- RESULT MAY HAVE SAME COMBINATION IN TERMS OF NUMBER
-- 42 7 6 2
-- 2 6 7 42
SELECT *
FROM MARKSIX NUM1, MARKSIX NUM2, MARKSIX NUM3, MARKSIX NUM4 -- 49 X 49 X 49 X 49
WHERE NUM1.NUM < NUM2.NUM
AND NUM2.NUM < NUM3.NUM
AND NUM3.NUM < NUM4.NUM;
-- CLASS MARKSIX (NUM1, NUM2, NUM3, NUM4, NUM5, NUM6) -> EQUALS()

-- Day 4
-- CREATE VIEW
CREATE VIEW DEPARTMENT_EMPLOYMENT_STAT
AS 
SELECT S.DEPT_CODE
, MIN(S.EMPLOYMENT_DATE) AS EARLIEST_EMPLOYMENT_DATE
, MAX(S.EMPLOYMENT_DATE) AS LATEST_EMPLOYMENT_DATE
, SUM(S.SALARY) AS TOTAL_SALARY
, COUNT(1) AS NUM_OF_STAFF
FROM STAFFS S
GROUP BY S.DEPT_CODE
;
-- SELECT VIEW
SELECT * FROM DEPARTMENT_EMPLOYMENT_STAT;
-- VIEW -> REAL-TIME LOOKUP THE PHYSICAL TABLE
-- 1. NO IMPACT TO DATABASE WORKLOAD, BECAUSE THE SQL IS REAL-TIME EXECUTION
-- 2. BETTER FOR DATA SECURITY MANAGEMENT (TABLE/VIEW ACCESS RIGHT), BECAUSE TEAMS HAVE DIFFERENT DATA OWNERSHIP

SELECT * FROM CUSTOMER_VIP_INFO;

CREATE VIEW CUSTOMER_VIP_INFO
AS
SELECT ID, VIP
FROM CUSTOMER;


CREATE TABLE DEPT_INFO_REPORT (
	DEPT_CODE VARCHAR(2),
	AVG_SALARY DECIMAL(11, 2)
);

DROP PROCEDURE IF EXISTS INSERT_DEPT_INFO_REPORT;

-- PROCEDURE CODE
DELIMITER //

CREATE PROCEDURE INSERT_DEPT_INFO_REPORT() -- IN STAFF_ID INTEGER

BEGIN
	DECLARE done INT DEFAULT 0;
    DECLARE v_dept_code VARCHAR(2);
    DECLARE v_avg_salary DECIMAL(11, 2);
    
	DECLARE dept_cursor CURSOR FOR
        SELECT DEPT_CODE, ROUND(AVG(SALARY), 2)
        FROM STAFFS
        GROUP BY DEPT_CODE;
        
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    DELETE FROM DEPT_INFO_REPORT;
    
     -- Open the cursor
    OPEN dept_cursor;
    dept_loop: LOOP 
        FETCH dept_cursor INTO v_dept_code, v_avg_salary;
        IF done THEN
            LEAVE dept_loop;
        END IF;
        
        INSERT INTO DEPT_INFO_REPORT (DEPT_CODE, AVG_SALARY) VALUES (v_dept_code, v_avg_salary);
    END LOOP;
    CLOSE dept_cursor;
END;
//

DELIMITER ;

-- CALL PROCEDURE
CALL INSERT_DEPT_INFO_REPORT();
-- SELECT THE RESULT
SELECT * FROM DEPT_INFO_REPORT;


CREATE TABLE DEPT_STAFF_COUNT (
	DEPT_CODE VARCHAR(2),
    COUNT INT
);


DROP TRIGGER IF EXISTS DEPT_STAFF_COUNT_TRIGGER;

DELIMITER //

CREATE TRIGGER DEPT_STAFF_COUNT_TRIGGER
AFTER INSERT ON STAFFS
FOR EACH ROW
BEGIN
    DECLARE notfound INT DEFAULT 0;
    DECLARE v_dept_code VARCHAR(2);
    DECLARE v_avg_salary DECIMAL(11, 2);
    DECLARE v_found INT DEFAULT 0;
    
	DECLARE dept_cursor CURSOR FOR
        SELECT 1
        FROM DEPT_STAFF_COUNT
        WHERE DEPT_CODE = NEW.DEPT_CODE;
        
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET notfound = 1;
    
    DELETE FROM DEPT_INFO_REPORT;
    
     -- Open the cursor
    OPEN dept_cursor;
    dept_loop: LOOP 
        FETCH dept_cursor INTO v_found;
        IF notfound THEN
			INSERT INTO DEPT_STAFF_COUNT (DEPT_CODE, COUNT) VALUES (NEW.DEPT_CODE, 1);
            LEAVE dept_loop;
        END IF;
        UPDATE DEPT_STAFF_COUNT SET COUNT = COUNT + 1 WHERE DEPT_CODE = NEW.DEPT_CODE;
        LEAVE dept_loop;
    END LOOP;
    CLOSE dept_cursor;
END;
//

DELIMITER ;

INSERT INTO STAFFS (ID, STAFF_NAME, GENDER, SALARY, STAFF_EMAIL, DEPT_CODE) 
	VALUES (100, 'VINCENT WONG', 'M', 30000.5, 'VINCENTWONG@gmail.com', 'IT');
INSERT INTO STAFFS (ID, STAFF_NAME, GENDER, SALARY, STAFF_EMAIL, DEPT_CODE) 
	VALUES (101, 'SALLY WONG', 'M', 30000.5, 'SALLY@gmail.com', 'IT');
INSERT INTO STAFFS (ID, STAFF_NAME, GENDER, SALARY, STAFF_EMAIL, DEPT_CODE) 
	VALUES (102, 'BETTY WONG', 'M', 30000.5, 'BETTY@gmail.com', 'HR');
SELECT * FROM DEPT_STAFF_COUNT;
